\documentclass[11pt,a4paper]{report}

\begin{document}
\title{Distributed Chat Application: Final Report}
\author{Monarchs of Coding:\\
  Aigerim Serikbekova\\
  Aydin Akyol\\
  Fareed Qaseem\\
  Spyridon Kousidis\\
  Ozhan Azizi\\
  Vijendra Patel}
\date{March 2017}
\maketitle


\chapter{Introduction}

Chat systems refers to communication over the Internet, communication that offers a real-time transmission of messages from sender to receiver(s). There are many types of messages such as texts, multi-media, etc. In this project, we have been developing a reliable, secure, real-time, distributed chat system where users can exchange messages among each other. Our application can be accessed using PCs and Android mobile phones.
The system is made of three sub-systems mainly, which are: A server written in Elixir, a Java Desktop application, and an Android application. With a friendly graphical user interface.
At the beginning of the work, we defined several features that our system should deliver, some of them were priorities so the system can deliver a basic communication, the others were non-priorities which we could achieve some and left some for future work.

\section{Priority Features}
	\begin{itemize}
		\item Registering New Profile.
		\item Sign-in Process.
		\item Contacts Look-up.
  		\item Exchanging Text Messages.
 		\item Listing Existing Chats.
		\item Chats History.
		\item Sign-out Process.
	\end{itemize}

\section{Non-priority Features}
	\begin{itemize}
		\item Deleting Existing Chats.
		\item Managing a User's Profile.
		\item Participation in Group Chats.
		\item Exchangin Multimedia Messages.
	\end{itemize}

The whole developing process was made using Agile development methodology, we had several steps to develop every feature, starting from \emph{Backlog} which contains the ideas and sub ideas, \emph {Specify} which contains the notes and criteria we should satisfy during next steps, \emph{Implement} which is the programming phase, \emph{Test/QA} where the implemented features are tested against the criteria which was set in \emph{Specify} step, and finally \emph{Deployed} which means that this feature is completed.



\chapter{Review of Current Market}

% Can talk about WhatsApp, FB Messenger, WeChat, Kik etc.

\section{Messaging protocols}

\subsection{XMPP}

\subsection{MQTT}

\section{Encrypted communication protocols}

\subsection{Signal}


\chapter{Requirements and Design}

% Does overall system design go in here? Check final report handout.

\chapter{Implementation}

\subsection{Toolkit}

\begin{itemize}
  \item Docker:
  \item pyinvoke: A task runner in Python.
\end{itemize}

\section{Unit Testing}

\subsection{Why Unit Testing}
One of the dynamic testing methods we did is unit testing, where this breaks down the tests into smallest parts of the application into units and tests them independently and individually. Since unit testing is white box testing we have different ways of checking for coverage. We were focusing on two coverage, statement and branch testing. Adequacy criteria for statement testing is for each statement to be executed at least once, and the adequacy criteria for branch testing are each branch must be executed once. The rationale for this is that a faulty statement or branch can only be revealed if it is executed. 

\subsection{Mocking}
We used mocking for several of different reasons such as test the logic of the class in isolation; provide a response to check the behaviour of the rest of the function. We used it when we wanted to return a particular value when the method is called. E.g. in the “RegistrationControllerTest.java” the “testSuccessfulRegisterUser” test function we mocked the configuration object (which provides global configuration variables for the application). We mocked the configuration, because when our registration controller calls the http client to post we need a URL. The URL is retrieved from a function inside the configuration class. Therefore using “when(mockConfiguration
.getBackendAddress()).thenReturn(baseUrl.toString())” we enable to provide the URL when “getBackendAddress“ function is called. We have also mocked the server by using “MockWebServer” library, which this allows us to specify the response and then we can verify the right nodes are being executed and test on what was returned. Hence, in our test function “testSuccessfulRegisterUser” we created a user named “test” and if the right nodes have been executed then user name would change to the expected username “alice”. 

\subsection{Report}
We used Java code coverage library to output our report for our testing… 

\section{Android Client}

\subsection{Libraries}

\section{Desktop Client}

\subsection{Libraries}

\section{Backend}

The backend for this application has been created with the Elixir programming language. Elixir is a functional language that uses the Erlang VM(Virtual Machine) to run its code \cite{website:elixir_homepage}. The primary reason choosing Elixir was because of its built-in distributed capabilities, which allows every erlang node to be aware of any publish-subscribe channel we created and thus the backend can easily scale horizontally without some nodes losing topic information. Without this functionality, we could have created a Redis cluster to handle the publish-subscribe channels, however this would have made the backend more complex.

\subsection{Libraries}

\begin{tabular}{ | l | p{11cm} |}
  \hline Package name & Usage \\ \hline
  phoenix & todo \\
  phoenix\_pubsub & todo \\
  phoenix\_ecto & todo \\ \hline
  postgrex & todo \\
  comeonin & todo \\
  guardian & todo \\
  jose & todo \\ \hline
  excoveralls & Coverage reporting \\
  credo & Static analysis \\
  dogma & Static analysis \\
  \hline
\end{tabular}

\subsubsection{Phoenix Framework}


\subsubsection{Static Analysis}

Credo and Dogma

\subsection{Amazon Web Services with Hashicorp's Terraform}


\chapter{Team Work}

\chapter{Evaluation}

% What we've achieved.

\section{Security}

% To what extent this system is secure.

\chapter{Peer Review}

\bibliographystyle{plain}
\bibliography{final-report}{}
\end{document}
