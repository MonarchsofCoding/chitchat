\documentclass[11pt,a4paper]{report}

\begin{document}
\title{Distributed Chat Application: Final Report}
\author{Monarchs of Coding:\\
  Aigerim Serikbekova\\
  Aydin Akyol\\
  Fareed Qaseem\\
  Spyridon Kousidis\\
  Ozhan Azizi\\
  Vijendra Patel}
\date{March 2017}
\maketitle


\chapter{Introduction}

Chat systems refers to communication over the Internet, communication that offers a real-time transmission of messages from sender to receiver(s). There are many types of messages such as texts, multi-media, etc. In this project, we have been developing a reliable, secure, real-time, distributed chat system where users can exchange messages among each other. Our application can be accessed using PCs and Android mobile phones.
The system is made of three sub-systems mainly, which are: A server written in Elixir, a Java Desktop application, and an Android application. With a friendly graphical user interface.
At the beginning of the work, we defined several features that our system should deliver, some of them were priorities so the system can deliver a basic communication, the others were non-priorities which we could achieve some and left some for future work.

\section{Priority Features}
	\begin{itemize}
		\item Registering New Profile.
		\item Sign-in Process.
		\item Contacts Look-up.
  		\item Exchanging Text Messages.
 		\item Listing Existing Chats.
		\item Chats History.
		\item Sign-out Process.
	\end{itemize}

\section{Non-priority Features}
	\begin{itemize}
		\item Deleting Existing Chats.
		\item Managing a User's Profile.
		\item Participation in Group Chats.
		\item Exchangin Multimedia Messages.
	\end{itemize}

The whole developing process was made using Agile development methodology, we had several steps to develop every feature, starting from \emph{Backlog} which contains the ideas and sub ideas, \emph {Specify} which contains the notes and criteria we should satisfy during next steps, \emph{Implement} which is the programming phase, \emph{Test/QA} where the implemented features are tested against the criteria which was set in \emph{Specify} step, and finally \emph{Deployed} which means that this feature is completed.



\chapter{Review of Current Market}

% Can talk about WhatsApp, FB Messenger, WeChat, Kik etc.

\section{Messaging protocols}

\subsection{XMPP}
XMPP stands for "Extensible Messaging and Presence Protocol", it is an open XML technology for real-time communication. Many applications use XMPP due to its ability to determine the state of each entity, it can determine if the entity is online, offline, or busy, etc. XMPP also uses a unique and very efficient messaging exchanging mechanism, while other protocols create many unnecessary steps and packets which might not satisfy the real-time characteristic. One more interesting feature of XMPP is that it is scalable and adaptive, it is designed to grow and adapt to size changes.


\subsection{MQTT}
MQTT stands for "Message Queuing Telemetry Transport". MQTT is a very light messaging protocol which is used for peer to peer messages exchanging usually, and it uses publish/subscribe communication pattern as well. It is a good choice for applications that run over different types of networks which may experience different levels of latencies. Therefore, many messages exchanging applications use MQTT nowadays, such as Facebook Messenger. And it is used widely not only because of it is efficient mechanism, but also because it is ability to preserve battery power due to the few actions it requires to work. It is worthy to mention that MQTT is used to implement many IoT applications as well.


\section{Encrypted communication protocols}

\subsection{Why encryption}
The exchanging message process is the main feature of our application and for this reason the security on our communication channel was one of our first goals. During our security protocols research we came out with three different models (Gnu PG key chain model, RSA ,Signal). 

\subsection{RSA-GPG}
The Gnu PG key chain model uses both symmetric and asymmetric key encryption protocols. The RSA public key cryptosystem model uses assymetric key encryption. We prefer to use RSA instead of AES or 3DES for the reason that the last two is symmetric key encryptio. For the RSA we used the cipheralgorithm of ECB(Electronic Code Book) instead of OFB,CBC and CFB as it is faster and simpler on his implementation. Beginning with the libraries, we used the Java SE Security and its libraries in order to apply our cryptographic protocols in the CryptoBox(Android) and Cryptofunctions(JavaDesktop) classes. On the side of client, we generate a pair of keys (a public and its private) and we store it locally as instances of the UserModel class. The generator of this pair uses the RSA algorithm with 4096 key length which is important as the factorization uses big prime numbers that are extremely difficult to be guessed. After the creation of the two keys, we send the public key to our server. The creation of the two keys takes place during the login activity. Each time a user wants to start a conversation with another user must ask for his public key from the server. The user encrypts his message with the user’s public key and he sends it. The receiver on the other side can decrypt the encrypted message as he is the only one who knows the private key that is needed.

\subsection{Signal}
Signal is a protocol developed by Open Whisper Systems. On this protocol clientsl using their mobile numbers as id can send end-to-end encrypted messages to each other. One of the feature of signal is that clients create a pair of public and private keys which are stored to the endpoints. Moreover, clients can be authenticated using key fingerprints (or scan QR codes). Using a passphrase the user can encrypt the whole database where he stores his messages. One last feature is that users can keep for a specific time their messages to the database using a timer. One of the limitation is that the user can be registered in only one device. 

\subsection{Applying to our application}
In our application we used a combination of this research as we described on the previous paragraphs and we manage to use our application in both desktop and mobile device for the one user. In order to succeed on this approach we put some limitations to our system. The first is that user does not keep any message history on his local data as everything is deleted when the users are log out. The second one is that each time the user tries to connect from a different device he creates a different public-private key pair. The new generated public key replaces the previous in our webserver database. That helps our user to protect his message even if his device was stolen or even if he had forgotten his application open to a, accessible from others, device.



\chapter{Requirements and Design}

% Does overall system design go in here? Check final report handout.

\chapter{Implementation}

\subsection{Toolkit}

\begin{itemize}
  \item Docker:
  \item pyinvoke: A task runner in Python.
\end{itemize}

\section{Unit Testing}

\subsection{Why Unit Testing}
Testing the code and its functionality has the same importance as writing our actual code. During the process of testing the programmer can test his code and the expected results that he wants to have from these tests.The first one, is the JUnit unit testing framework where we test the functionality of our User-Interface environment. These tests include: the functionality of interface buttons and their behaviour after click on them, the error display messages after a wrong evaluation or error messages from the server and finally the transfer between stages and scenes on Java Fx. The main requirement for using this library was to set an unique ID for each object that we had to test and to create unique users depending on the scene that we were testing for instance login username or register user name.The dynamic testing methods we did is unit testing, where this breaks down the tests into smallest parts of the application into units and tests them independently and individually. Since unit testing is white box testing we have different ways of checking for coverage. We were focusing on two coverage, statement and branch testing. Adequacy criteria for statement testing is for each statement to be executed at least once, and the adequacy criteria for branch testing are each branch must be executed once. The rationale for this is that a faulty statement or branch can only be revealed if it is executed. 

\subsection{Mocking}
The second testing framework library that we used is Mockito. We used mocking for several of different reasons such as test the logic of the class in isolation; provide a response to check the behaviour of the rest of the function. We used it when we wanted to return a particular value when the method is called. E.g. in the “RegistrationControllerTest.java” the “testSuccessfulRegisterUser” test function we mocked the configuration object (which provides global configuration variables for the application). We mocked the configuration, because when our registration controller calls the http client to post we need a URL. The URL is retrieved from a function inside the configuration class. Therefore using “when(mockConfiguration
.getBackendAddress()).thenReturn(baseUrl.toString())” we enable to provide the URL when “getBackendAddress“ function is called. We have also mocked the server by using “MockWebServer” library, which this allows us to specify the response and then we can verify the right nodes are being executed and test on what was returned. Hence, in our test function “testSuccessfulRegisterUser” we created a user named “test” and if the right nodes have been executed then user name would change to the expected username “alice”. 

\subsection{Report}
We used Java code coverage library to output our report for our testing… 

\section{Android Client}

\subsection{Libraries}

\section{Desktop Client}

\subsection{Libraries}

\section{Backend}

The backend for this application has been created with the Elixir programming language. Elixir is a functional language that uses the Erlang VM(Virtual Machine) to run its code \cite{website:elixir_homepage}. The primary reason choosing Elixir was because of its built-in distributed capabilities, which allows every erlang node to be aware of any publish-subscribe channel we created and thus the backend can easily scale horizontally without some nodes losing topic information. Without this functionality, we could have created a Redis cluster to handle the publish-subscribe channels, however this would have made the backend more complex.

\subsection{Libraries}

\begin{tabular}{ | l | p{11cm} |}
  \hline Package name & Usage \\ \hline
  phoenix & todo \\
  phoenix\_pubsub & todo \\
  phoenix\_ecto & todo \\ \hline
  postgrex & todo \\
  comeonin & todo \\
  guardian & todo \\
  jose & todo \\ \hline
  excoveralls & Coverage reporting \\
  credo & Static analysis \\
  dogma & Static analysis \\
  \hline
\end{tabular}

\subsubsection{Phoenix Framework}


\subsubsection{Static Analysis}

Credo and Dogma

\subsection{Amazon Web Services with Hashicorp's Terraform}


\chapter{Team Work}

\chapter{Evaluation}

% What we've achieved.

\section{Security}

% To what extent this system is secure.

\chapter{Peer Review}

\bibliographystyle{plain}
\bibliography{final-report}{
https://www.gnupg.org/
https://en.wikipedia.org/wiki/RSA_(cryptosystem)
http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html
http://junit.org/junit4/
http://site.mockito.org/

}
\end{document}
