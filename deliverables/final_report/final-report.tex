\documentclass[11pt,a4paper]{report}

\begin{document}
\title{Distributed Chat Application: Final Report}
\author{Monarchs of Coding:\\
  Aigerim Serikbekova\\
  Aydin Akyol\\
  Fareed Qaseem\\
  Spyridon Kousidis\\
  Ozhan Azizi\\
  Vijendra Patel}
\date{March 2017}
\maketitle


\chapter{Introduction}

Chat systems refers to communication over the Internet, communication that offers a real-time transmission of messages from sender to receiver(s). There are many types of messages such as texts, multi-media, etc. In this project, we have been developing a reliable, secure, real-time, distributed chat system where users can exchange messages among each other. Our application can be accessed using PCs and Android mobile phones.
The system is made of three sub-systems mainly, which are: A server written in Elixir, a Java Desktop application, and an Android application. With a friendly graphical user interface.
At the beginning of the work, we defined several features that our system should deliver, some of them were priorities so the system can deliver a basic communication, the others were non-priorities which we could achieve some and left some for future work.

\section{Priority Features}
	\begin{itemize}
		\item Registering New Profile.
		\item Sign-in Process.
		\item Contacts Look-up.
  		\item Exchanging Text Messages.
 		\item Listing Existing Chats.
		\item Chats History.
		\item Sign-out Process.
	\end{itemize}

\section{Non-priority Features}
	\begin{itemize}
		\item Deleting Existing Chats.
		\item Managing a User's Profile.
		\item Participation in Group Chats.
		\item Exchangin Multimedia Messages.
	\end{itemize}

The whole developing process was made using Agile development methodology, we had several steps to develop every feature, starting from \emph{Backlog} which contains the ideas and sub ideas, \emph {Specify} which contains the notes and criteria we should satisfy during next steps, \emph{Implement} which is the programming phase, \emph{Test/QA} where the implemented features are tested against the criteria which was set in \emph{Specify} step, and finally \emph{Deployed} which means that this feature is completed.



\chapter{Review of Current Market}

% Can talk about WhatsApp, FB Messenger, WeChat, Kik etc.

\section{Messaging protocols}

\subsection{XMPP}
XMPP stands for "Extensible Messaging and Presence Protocol", it is an open XML technology for real-time communication. Many applications use XMPP due to its ability to determine the state of each entity, it can determine if the entity is online, offline, or busy, etc. XMPP also uses a unique and very efficient messaging exchanging mechanism, while other protocols create many unnecessary steps and packets which might not satisfy the real-time characteristic. One more interesting feature of XMPP is that it is scalable and adaptive, it is designed to grow and adapt to size changes.


\subsection{MQTT}
MQTT stands for "Message Queuing Telemetry Transport". MQTT is a very light messaging protocol which is used for peer to peer messages exchanging usually, and it uses publish/subscribe communication pattern as well. It is a good choice for applications that run over different types of networks which may experience different levels of latencies. Therefore, many messages exchanging applications use MQTT nowadays, such as Facebook Messenger. And it is used widely not only because of it is efficient mechanism, but also because it is ability to preserve battery power due to the few actions it requires to work. It is worthy to mention that MQTT is used to implement many IoT applications as well.


\section{Encrypted communication protocols}

\subsection{Why encryption}
The exchanging message process is the main feature of our application and for this reason the security on our communication channel was one of our first goals. During our security protocols research we came out with three different models (Gnu PG key chain model, RSA ,Signal). 

\subsection{RSA-GPG}
The Gnu PG key chain model uses both symmetric and asymmetric key encryption protocols. The RSA public key cryptosystem model uses assymetric key encryption. We prefer to use RSA instead of AES or 3DES for the reason that the last two is symmetric key encryptio. For the RSA we used the cipheralgorithm of ECB(Electronic Code Book) instead of OFB,CBC and CFB as it is faster and simpler on his implementation. Beginning with the libraries, we used the Java SE Security and its libraries in order to apply our cryptographic protocols in the CryptoBox(Android) and Cryptofunctions(JavaDesktop) classes. On the side of client, we generate a pair of keys (a public and its private) and we store it locally as instances of the UserModel class. The generator of this pair uses the RSA algorithm with 4096 key length which is important as the factorization uses big prime numbers that are extremely difficult to be guessed. After the creation of the two keys, we send the public key to our server. The creation of the two keys takes place during the login activity. Each time a user wants to start a conversation with another user must ask for his public key from the server. The user encrypts his message with the user’s public key and he sends it. The receiver on the other side can decrypt the encrypted message as he is the only one who knows the private key that is needed.

\subsection{Signal}
Signal is a protocol developed by Open Whisper Systems. On this protocol clientsl using their mobile numbers as id can send end-to-end encrypted messages to each other. One of the feature of signal is that clients create a pair of public and private keys which are stored to the endpoints. Moreover, clients can be authenticated using key fingerprints (or scan QR codes). Using a passphrase the user can encrypt the whole database where he stores his messages. One last feature is that users can keep for a specific time their messages to the database using a timer. One of the limitation is that the user can be registered in only one device. 

\subsection{Applying to our application}
In our application we used a combination of this research as we described on the previous paragraphs and we manage to use our application in both desktop and mobile device for the one user. In order to succeed on this approach we put some limitations to our system. The first is that user does not keep any message history on his local data as everything is deleted when the users are log out. The second one is that each time the user tries to connect from a different device he creates a different public-private key pair. The new generated public key replaces the previous in our webserver database. That helps our user to protect his message even if his device was stolen or even if he had forgotten his application open to a, accessible from others, device.



\chapter{Requirements and Design}

% Does overall system design go in here? Check final report handout.

\chapter{Implementation}

\subsection{Toolkit}

\begin{itemize}
  \item Docker:
  \item pyinvoke: A task runner in Python.
\end{itemize}

\section{Unit Testing}

\subsection{Why Unit Testing}
Testing the code and its functionality has the same importance as writing our actual code. During the process of testing the programmer can test his code and the expected results that he wants to have from these tests.The first one, is the JUnit unit testing framework where we test the functionality of our User-Interface environment. These tests include: the functionality of interface buttons and their behaviour after click on them, the error display messages after a wrong evaluation or error messages from the server and finally the transfer between stages and scenes on Java Fx. The main requirement for using this library was to set an unique ID for each object that we had to test and to create unique users depending on the scene that we were testing for instance login username or register user name.The dynamic testing methods we did is unit testing, where this breaks down the tests into smallest parts of the application into units and tests them independently and individually. Since unit testing is white box testing we have different ways of checking for coverage. We were focusing on two coverage, statement and branch testing. Adequacy criteria for statement testing is for each statement to be executed at least once, and the adequacy criteria for branch testing are each branch must be executed once. The rationale for this is that a faulty statement or branch can only be revealed if it is executed. 

\subsection{Mocking}
The second testing framework library that we used is Mockito. We used mocking for several of different reasons such as test the logic of the class in isolation; provide a response to check the behaviour of the rest of the function. We used it when we wanted to return a particular value when the method is called. E.g. in the “RegistrationControllerTest.java” the “testSuccessfulRegisterUser” test function we mocked the configuration object (which provides global configuration variables for the application). We mocked the configuration, because when our registration controller calls the http client to post we need a URL. The URL is retrieved from a function inside the configuration class. Therefore using “when(mockConfiguration
.getBackendAddress()).thenReturn(baseUrl.toString())” we enable to provide the URL when “getBackendAddress“ function is called. We have also mocked the server by using “MockWebServer” library, which this allows us to specify the response and then we can verify the right nodes are being executed and test on what was returned. Hence, in our test function “testSuccessfulRegisterUser” we created a user named “test” and if the right nodes have been executed then user name would change to the expected username “alice”. 

\subsection{Report}
We used Java code coverage library to output our report for our testing… 

\section{Android Client}

\subsection{Design}
Unlike the Java client, the Android client is designed to be as simple as it can get, since a simple chat app should be as simple and easy to use as it can get. So to achieve this objective, the Android client has sleek but simple design through layouts of activities (i.e. views). 
The login and registration layouts are primitive, with just a welcoming text, textboxes and buttons. However, the rest is designed to increase usability rather than having a better look for the application. 
To indicate which view is for what functionality, Android Support Library’s ActionBar is used, which is the blue bar with white texts that is visible at every activity. This ActionBar brings sleeker look to the activities, since a simple TextView looks rather like a last-minute job patch, whilst simply states what that activity is for. 
After the registration and login process, the application welcomes the users via a page with tabs. In Java client, the window can get large as it is desired, since it runs on desktop which has quite a lot of space on the screen. However, an Android device cannot be that big (Except tablets, which are the minority of the Android devices). So, to implement the three-fundamental functionality of chatting features, which are searching a user, chatting and having a chats list, a TabLayout is used. Via this element, one can switch through activities easily. The three functionality is separated to tabs as Chats, Search User and Current Chat. Unlike the Java client, the layout in Android client is designed to show the most recent chat, and users can access earlier chats through the list in Chat List tab. 
As one may know, Android system has a neat but small element called Toast to alert its user about errors or warnings. To display information to users, such as registration errors or information about successful logins, Toast is used on every occasion. The reason behind this is to maintain the sleek-but-simple design while making the implementation process for showing errors easier. One can choose Toast to have its easy implementation whilst having its minimalistic low profile appearance, rather than updating a TextView for errors.
Since the group aimed for a sleek-but-simple design, the icon is also desired to be a unique but a simple one. In addition, it’s also a plus not to use the generic auto-generated Android icon. The icon is designed to reflect the simplicity and the fundamental functionality of the application, hence is formed from a simple chat balloon containing the application name with a plain clear and bold font, whilst having a blue background, which is same as the ActionBar of all the activities.

\subsection{Implementation}
The way of implementing the whole application, as in structure and features, is the same with the Java client. However, the technical implementation is a bit different. In Java client, as stated, MVC is used as architectural pattern. However, MVC pattern is not completely suitable for the Android environment’s activity based structure, mainly because of binding the layout updates on activities’ context. Hence, on the implementation of Android client an edited version of MVC is applied, where activities are considered as semi-controllers as well, which updates the layouts (i.e. views) but also handles some of the functionalities that is entitled to that activity. To give an example, the login activity handles getting input and giving information to the user, and at the same time handles the login request’s response from the backend, since it is forced to intervene the layout of an activity inside the activity’s own class. Nonetheless, this intervention on the actual design of MVC pattern doesn’t mean the architecture doesn’t have controller-to-model link. Main functionalities of the features of ChitChat are handled with controllers, and the business logic is handled via models. 
As Monarchs of Coding, the group wanted to deliver the application as many people as possible. For the sake of this objective, Android API level 19 (i.e. version 4.4 KitKat) is chosen as the minimum required API level, to cover approximately 75\% of the Android device pool, whilst having the necessary libraries that the API offers. Even though the minimum SDK is API level 19, the targeted API level for the Android client is API 25 (i.e. version 7.1) to reach the maximum amount of core and support Android libraries.
As stated before, dependency injection is applied throughout the clients, for the sake of achieving inversion of control, which breaks down the code to make unit testing easier, primarily. To enable dependency injection, a library which is owned by Google called Dagger 2 (refer Android - Libraries for more information). Unlike Spring Framework, which is used for the Java client, Dagger 2 has a whole different structure to apply dependency injection, which required to create class files inside the root of the project directory.
As the Java client, the Android client is using REST services to send requests to the backend. This decision resulted as having an easier and stateless implementation of requests sent to backend in Android client. To implement this service, many approaches came into practise. As a first approach, a request sending class is implemented with primitive http classes which is provided with the Android core library. For the sake of ease of implementation and efficiency, this design scraped almost immediately. Before scrapping, AsyncTask is also considered to handle the primitive http functions, but again for the same reason this solution also vetoed. To solve this problem without using any kind of thread, a library called Volley is used (refer Android – Libraries for more information). Via implementing the class for sending these requests with Volley, REST services became much easier to use inside the application. In addition, with getting rid of manual thread implementation, there is a considerable amount of improvement in efficiency and performance. 
To handle incoming messages and incoming requests from backend (like force logout), the Android application has an ongoing service in background. This service can get requests even the application is not in focus, and since there is no manual thread implementation is present, the resources for such a service is relatively low. To actually open a socket and a channel to the backend, a library called JavaPhoenixChannels (refer Android - Libraries for more information) is used.
As explained above, encryption is enabled throughout the system of ChitChat. To enable this security measurement, a cryptologic class formed from Java’s own security class. This class is similar between Java and Android clients, with differences with the way encoding is handled, since Android only allows to use a Base64 class from its own library.


\subsection{Problems Faced}

\subsection{Libraries}

\section{Desktop Client}

\subsection{Libraries}

\section{Backend}

The backend for this application has been created with the Elixir programming language. Elixir is a functional language that uses the Erlang VM(Virtual Machine) to run its code \cite{website:elixir_homepage}. The primary reason choosing Elixir was because of its built-in distributed capabilities, which allows every erlang node to be aware of any publish-subscribe channel we created and thus the backend can easily scale horizontally without some nodes losing topic information. Without this functionality, we could have created a Redis cluster to handle the publish-subscribe channels, however this would have made the backend more complex.

\subsection{Libraries}

\begin{tabular}{ | l | p{11cm} |}
  \hline Package name & Usage \\ \hline
  phoenix & todo \\
  phoenix\_pubsub & todo \\
  phoenix\_ecto & todo \\ \hline
  postgrex & todo \\
  comeonin & todo \\
  guardian & todo \\
  jose & todo \\ \hline
  excoveralls & Coverage reporting \\
  credo & Static analysis \\
  dogma & Static analysis \\
  \hline
\end{tabular}

\subsubsection{Phoenix Framework}


\subsubsection{Static Analysis}

Credo and Dogma

\subsection{Amazon Web Services with Hashicorp's Terraform}


\chapter{Team Work}

\chapter{Evaluation}

% What we've achieved.

\section{Security}
\subsubsection{Why encryption}
After the wikileaks of Snowden people become more aware about the security of their communications. It is very difficult to succeed on a 100 per cent secure system. On our implementation we used all the security protocols that we already knows and we change them in order to cover our application demandings. All of our exchanging messages are encrypted and we are using some id in order to avoid a man in the middle attack. Even if an attacker steal the encrypted message it is very hard to decrypt it as it takes a long time. Moreover the value of information that he is going to collect after decryption is useless as the keys change in every log in of a user.
\subsubsection{Username and Password}
The first part of our application that we have to think about security was the front end implementation and specifically the registration form. We used two rules in order a user to be eligible to be sign up to our database. The first was his username to be at least 3 characters and his password 8. Both password and username are checked to the side of the front end and to the back end. The reason that we choose 8character length password it is for a future security implementation where we can use it as a signature of our user. 
\subsubsection{Json-Https}
As we described above the client communicates with the server exchanging information. For this reason we used https connection exchanging Json messages. In order to implement this we used okhttp (Java Desktop) and Volley (Android). 
\subsubsection{Authentication Tokens}
After the registration process the user tries to login to our application using his username and his password. The server receives the https post request with his username and password and checks him on the database. If the user exists then he responds him with an authentication token .  This token it is used as signature on the header of the message when the user tries to sends a message to an other client. 
\subsubsection{Encryption}
On the side of Encryption as we described to our previous sections we used Assymetric key encryption using a public and a private key. Both Java Desktop and Android Client use the same Java SE security libraries generating using RSA (ECB) the pair of keys using a 4096 key length during the generation process. 
\subsubsection{Server-Side maybe}

% To what extent this system is secure.

\chapter{Peer Review}

\bibliographystyle{plain}
\bibliography{final-report}{
https://www.gnupg.org/
https://en.wikipedia.org/wiki/RSA_(cryptosystem)
http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html
http://junit.org/junit4/
http://site.mockito.org/

}
\end{document}
